{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nWhile images can often be represented as plain \nArray\ns, sometimes additional information about the \"meaning\" of each axis of the array is needed.  For example, in a 3-dimensional MRI scan, the voxels may not have the same spacing along the z-axis that they do along the x- and y-axes, and this fact should be accounted for during the display and/or analysis of such images.  Likewise, a movie has two spatial axes and one temporal axis; this fact may be relevant for how one performs image processing.\n\n\nThis package combines features from \nAxisArrays\n and \nSimpleTraits\n to provide a convenient representation and programming paradigm for dealing with such images.\n\n\n\n\nInstallation\n\n\nPkg.add(\nImageAxes\n)\n\n\n\n\n\n\nUsage\n\n\n\n\nNames and locations\n\n\nThe simplest thing you can do is to provide names to your image axes:\n\n\nusing ImageAxes\nimg = AxisArray(reshape(1:192, (8,8,3)), :x, :y, :z)\n\n\n\n\n3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1:8\n    :y, 1:8\n    :z, 1:3\nAnd data, a 8\u00d78\u00d73 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1   9  17  25  33  41  49  57\n 2  10  18  26  34  42  50  58\n 3  11  19  27  35  43  51  59\n 4  12  20  28  36  44  52  60\n 5  13  21  29  37  45  53  61\n 6  14  22  30  38  46  54  62\n 7  15  23  31  39  47  55  63\n 8  16  24  32  40  48  56  64\n\n[:, :, 2] =\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128\n\n[:, :, 3] =\n 129  137  145  153  161  169  177  185\n 130  138  146  154  162  170  178  186\n 131  139  147  155  163  171  179  187\n 132  140  148  156  164  172  180  188\n 133  141  149  157  165  173  181  189\n 134  142  150  158  166  174  182  190\n 135  143  151  159  167  175  183  191\n 136  144  152  160  168  176  184  192\n\n\n\n\nAs described in more detail in the \nAxisArrays documentation\n, you can now take slices like this:\n\n\nsl = img[Axis{:z}(2)]\n\n\n\n\n2-dimensional AxisArray{Int64,2,...} with axes:\n    :x, 1:8\n    :y, 1:8\nAnd data, a 8\u00d78 SubArray{Int64,2,Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}},Tuple{Colon,Colon,Int64},true}:\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128\n\n\n\n\nYou can also give units to the axes:\n\n\nusing ImageAxes, Unitful\nconst mm = u\nmm\n\nimg = AxisArray(reshape(1:192, (8,8,3)),\n                Axis{:x}(1mm:1mm:8mm),\n                Axis{:y}(1mm:1mm:8mm),\n                Axis{:z}(2mm:3mm:8mm))\n\n\n\n\n3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1 mm:1 mm:8 mm\n    :y, 1 mm:1 mm:8 mm\n    :z, 2 mm:3 mm:8 mm\nAnd data, a 8\u00d78\u00d73 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1   9  17  25  33  41  49  57\n 2  10  18  26  34  42  50  58\n 3  11  19  27  35  43  51  59\n 4  12  20  28  36  44  52  60\n 5  13  21  29  37  45  53  61\n 6  14  22  30  38  46  54  62\n 7  15  23  31  39  47  55  63\n 8  16  24  32  40  48  56  64\n\n[:, :, 2] =\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128\n\n[:, :, 3] =\n 129  137  145  153  161  169  177  185\n 130  138  146  154  162  170  178  186\n 131  139  147  155  163  171  179  187\n 132  140  148  156  164  172  180  188\n 133  141  149  157  165  173  181  189\n 134  142  150  158  166  174  182  190\n 135  143  151  159  167  175  183  191\n 136  144  152  160  168  176  184  192\n\n\n\n\nwhich specifies that \nx\n and \ny\n have spacing of 1mm and \nz\n has a spacing of 3mm, as well as the location of the center of each voxel.\n\n\n\n\nTemporal axes\n\n\nAny array possessing an axis \nAxis{:time}\n will be recognized as having a temporal dimension.  Given an array \nA\n,\n\n\nusing ImageAxes, Unitful\nconst s = u\ns\n\nimg = AxisArray(reshape(1:9*300, (3,3,300)),\n                Axis{:x}(1:3),\n                Axis{:y}(1:3),\n                Axis{:time}(1s/30:1s/30:10s))\n\n\n\n\n3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1:3\n    :y, 1:3\n    :time, 0.03333333333333333 s:0.03333333333333333 s:10.0 s\nAnd data, a 3\u00d73\u00d7300 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1  4  7\n 2  5  8\n 3  6  9\n\n[:, :, 2] =\n 10  13  16\n 11  14  17\n 12  15  18\n\n[:, :, 3] =\n 19  22  25\n 20  23  26\n 21  24  27\n\n...\n\n[:, :, 298] =\n 2674  2677  2680\n 2675  2678  2681\n 2676  2679  2682\n\n[:, :, 299] =\n 2683  2686  2689\n 2684  2687  2690\n 2685  2688  2691\n\n[:, :, 300] =\n 2692  2695  2698\n 2693  2696  2699\n 2694  2697  2700\n\n\n\n\nyou can retrieve its temporal axis with\n\n\nax = timeaxis(img)\n\n\n\n\nAxisArrays.Axis{:time,StepRange{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}},Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}}}(0.03333333333333333 s:0.03333333333333333 s:10.0 s)\n\n\n\n\nand index it like\n\n\n# img[ax(3)]\n\n\n\n\nYou can also specialize methods like this:\n\n\nusing ImageAxes, SimpleTraits\n@traitfn nimages{AA\n:AxisArray;  HasTimeAxis{AA}}(img::AA) = length(timeaxis(img))\n@traitfn nimages{AA\n:AxisArray; !HasTimeAxis{AA}}(img::AA) = 1\n\n\n\n\nnimages (generic function with 3 methods)\n\n\n\n\nwhere the pre-defined \nHasTimeAxis\n trait will restrict that method to arrays that have a timeaxis. A more complex example is\n\n\nusing ImageAxes, SimpleTraits\n@traitfn meanintensity{AA\n:AxisArray; !HasTimeAxis{AA}}(img::AA) = mean(img)\n@traitfn function meanintensity{AA\n:AxisArray; HasTimeAxis{AA}}(img::AA)\n    ax = timeaxis(img)\n    n = length(x)\n    intensity = zeros(eltype(img), n)\n    for ti = 1:n\n        sl = img[ax[ti]]  # the image slice at time ax[ti]\n        intensity[ti] = mean(sl)\n    end\n    intensity\nend\n\n\n\n\nand, when appropriate, it will return the mean intensity at each timeslice.\n\n\n\n\nCustom temporal axes\n\n\nUsing \nSimpleTraits\n's \n@traitimpl\n, you can add \nAxis{:t}\n or \nAxis{:scantime}\n or any other name to the list of axes that have a temporal dimension:\n\n\nusing ImageAxes, SimpleTraits\n@traitimpl TimeAxis{Axis{:t}}\n\n\n\n\nNote this declaration affects all arrays throughout your entire session.  Moreover, it should be made before calling any functions on array-types that possess such axes; a convenient place to do this is right after you say \nusing ImageAxes\n in your top-level script.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "While images can often be represented as plain  Array s, sometimes additional information about the \"meaning\" of each axis of the array is needed.  For example, in a 3-dimensional MRI scan, the voxels may not have the same spacing along the z-axis that they do along the x- and y-axes, and this fact should be accounted for during the display and/or analysis of such images.  Likewise, a movie has two spatial axes and one temporal axis; this fact may be relevant for how one performs image processing.  This package combines features from  AxisArrays  and  SimpleTraits  to provide a convenient representation and programming paradigm for dealing with such images.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg.add( ImageAxes )", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/#names-and-locations", 
            "text": "The simplest thing you can do is to provide names to your image axes:  using ImageAxes\nimg = AxisArray(reshape(1:192, (8,8,3)), :x, :y, :z)  3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1:8\n    :y, 1:8\n    :z, 1:3\nAnd data, a 8\u00d78\u00d73 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1   9  17  25  33  41  49  57\n 2  10  18  26  34  42  50  58\n 3  11  19  27  35  43  51  59\n 4  12  20  28  36  44  52  60\n 5  13  21  29  37  45  53  61\n 6  14  22  30  38  46  54  62\n 7  15  23  31  39  47  55  63\n 8  16  24  32  40  48  56  64\n\n[:, :, 2] =\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128\n\n[:, :, 3] =\n 129  137  145  153  161  169  177  185\n 130  138  146  154  162  170  178  186\n 131  139  147  155  163  171  179  187\n 132  140  148  156  164  172  180  188\n 133  141  149  157  165  173  181  189\n 134  142  150  158  166  174  182  190\n 135  143  151  159  167  175  183  191\n 136  144  152  160  168  176  184  192  As described in more detail in the  AxisArrays documentation , you can now take slices like this:  sl = img[Axis{:z}(2)]  2-dimensional AxisArray{Int64,2,...} with axes:\n    :x, 1:8\n    :y, 1:8\nAnd data, a 8\u00d78 SubArray{Int64,2,Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}},Tuple{Colon,Colon,Int64},true}:\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128  You can also give units to the axes:  using ImageAxes, Unitful\nconst mm = u mm \nimg = AxisArray(reshape(1:192, (8,8,3)),\n                Axis{:x}(1mm:1mm:8mm),\n                Axis{:y}(1mm:1mm:8mm),\n                Axis{:z}(2mm:3mm:8mm))  3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1 mm:1 mm:8 mm\n    :y, 1 mm:1 mm:8 mm\n    :z, 2 mm:3 mm:8 mm\nAnd data, a 8\u00d78\u00d73 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1   9  17  25  33  41  49  57\n 2  10  18  26  34  42  50  58\n 3  11  19  27  35  43  51  59\n 4  12  20  28  36  44  52  60\n 5  13  21  29  37  45  53  61\n 6  14  22  30  38  46  54  62\n 7  15  23  31  39  47  55  63\n 8  16  24  32  40  48  56  64\n\n[:, :, 2] =\n 65  73  81  89   97  105  113  121\n 66  74  82  90   98  106  114  122\n 67  75  83  91   99  107  115  123\n 68  76  84  92  100  108  116  124\n 69  77  85  93  101  109  117  125\n 70  78  86  94  102  110  118  126\n 71  79  87  95  103  111  119  127\n 72  80  88  96  104  112  120  128\n\n[:, :, 3] =\n 129  137  145  153  161  169  177  185\n 130  138  146  154  162  170  178  186\n 131  139  147  155  163  171  179  187\n 132  140  148  156  164  172  180  188\n 133  141  149  157  165  173  181  189\n 134  142  150  158  166  174  182  190\n 135  143  151  159  167  175  183  191\n 136  144  152  160  168  176  184  192  which specifies that  x  and  y  have spacing of 1mm and  z  has a spacing of 3mm, as well as the location of the center of each voxel.", 
            "title": "Names and locations"
        }, 
        {
            "location": "/#temporal-axes", 
            "text": "Any array possessing an axis  Axis{:time}  will be recognized as having a temporal dimension.  Given an array  A ,  using ImageAxes, Unitful\nconst s = u s \nimg = AxisArray(reshape(1:9*300, (3,3,300)),\n                Axis{:x}(1:3),\n                Axis{:y}(1:3),\n                Axis{:time}(1s/30:1s/30:10s))  3-dimensional AxisArray{Int64,3,...} with axes:\n    :x, 1:3\n    :y, 1:3\n    :time, 0.03333333333333333 s:0.03333333333333333 s:10.0 s\nAnd data, a 3\u00d73\u00d7300 Base.ReshapedArray{Int64,3,UnitRange{Int64},Tuple{}}:\n[:, :, 1] =\n 1  4  7\n 2  5  8\n 3  6  9\n\n[:, :, 2] =\n 10  13  16\n 11  14  17\n 12  15  18\n\n[:, :, 3] =\n 19  22  25\n 20  23  26\n 21  24  27\n\n...\n\n[:, :, 298] =\n 2674  2677  2680\n 2675  2678  2681\n 2676  2679  2682\n\n[:, :, 299] =\n 2683  2686  2689\n 2684  2687  2690\n 2685  2688  2691\n\n[:, :, 300] =\n 2692  2695  2698\n 2693  2696  2699\n 2694  2697  2700  you can retrieve its temporal axis with  ax = timeaxis(img)  AxisArrays.Axis{:time,StepRange{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}},Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}}}(0.03333333333333333 s:0.03333333333333333 s:10.0 s)  and index it like  # img[ax(3)]  You can also specialize methods like this:  using ImageAxes, SimpleTraits\n@traitfn nimages{AA :AxisArray;  HasTimeAxis{AA}}(img::AA) = length(timeaxis(img))\n@traitfn nimages{AA :AxisArray; !HasTimeAxis{AA}}(img::AA) = 1  nimages (generic function with 3 methods)  where the pre-defined  HasTimeAxis  trait will restrict that method to arrays that have a timeaxis. A more complex example is  using ImageAxes, SimpleTraits\n@traitfn meanintensity{AA :AxisArray; !HasTimeAxis{AA}}(img::AA) = mean(img)\n@traitfn function meanintensity{AA :AxisArray; HasTimeAxis{AA}}(img::AA)\n    ax = timeaxis(img)\n    n = length(x)\n    intensity = zeros(eltype(img), n)\n    for ti = 1:n\n        sl = img[ax[ti]]  # the image slice at time ax[ti]\n        intensity[ti] = mean(sl)\n    end\n    intensity\nend  and, when appropriate, it will return the mean intensity at each timeslice.", 
            "title": "Temporal axes"
        }, 
        {
            "location": "/#custom-temporal-axes", 
            "text": "Using  SimpleTraits 's  @traitimpl , you can add  Axis{:t}  or  Axis{:scantime}  or any other name to the list of axes that have a temporal dimension:  using ImageAxes, SimpleTraits\n@traitimpl TimeAxis{Axis{:t}}  Note this declaration affects all arrays throughout your entire session.  Moreover, it should be made before calling any functions on array-types that possess such axes; a convenient place to do this is right after you say  using ImageAxes  in your top-level script.", 
            "title": "Custom temporal axes"
        }
    ]
}